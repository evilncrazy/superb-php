<?php
class Superb {
   private $children = array();
   private $name;
   private $attrs = array();
   
   public function __construct($name, $inner = null) {
      $this->name = $name;
      if($inner !== null) {
         $this->attrs['inner'] = $inner;
      }
   }
   
   public function add($child) {
      $this->children = array_merge($this->children, (array)$child);
   }
   
   public function set($attr, $val) {
      $this->attrs[$attr] = $val;
   }
   
   public function as_string($indent = "") {
      $new_indent = $indent . "   ";
      
      if($this->name == 'raw') {
         return $this->attrs['inner'];
      } else if(array_key_exists($this->name, array_fill_keys(array('br', 'input', 'img', 'hr', 'input', 'meta'), true))) {
         /* ^ very awkward, need some sort of static variable to do this,
            but static variables can't be directly initialized to array_fill_keys(...).
            If using normal array, need to use in_array, which is O(n) as opposed to O(1) */
         $attribs = "";
         foreach($this->attrs as $attr => $val) {
            $attribs .= " " . $attr . "='" . $val . "'";
         }
         
         return "<" . $this->name . $attribs . " />";
      } else {
         $inner = "";
         $attribs = "";

         if(count($this->children)) {
            if(count($this->children) == 1 && $this->children[0]->name == 'raw') {
               /* if the only child is a raw, then we want to inline this.
                  TODO: in the future, should have more flexibile inline system */
               $inner = $this->children[0]->as_string($new_indent);
            } else {
               foreach($this->children as $child) {
                  $inner .= "\n" . $new_indent . $child->as_string($new_indent);
               }
               $inner .= "\n" . $indent;
            }
         }
         
         foreach($this->attrs as $attr => $val) {
            $attribs .= " " . $attr . "='" . $val . "'";
         }
         
         return "<" . $this->name . $attribs . ">" . $inner . 
                "</" . $this->name . ">";
      }
   }
   
   public function __toString() {
      return $this->as_string();
   }
}

class Sp {
   private $top_level_su = array();
   
   public function get_top_su() {
      return $this->top_level_su;
   }
   
   public static function parse_options($su, $options) {
      foreach($options as $attr => $val) {
         $su->set($attr, $val);
      }
      return $su;
   }
   
   private function parse_args($name, $args, $save_su = false) {
      /* each arg can only be one of the following:
         1. string: raw text enclosed by the tag (inner html)
         2. array: contains optional attributes (e.g. class, id, name)
         3. function: calls the function, with any markup added to this node */
      $su = new Superb($name);
      if(count($args)) {
         $su_children = array();
         foreach($args as $arg) {
            if(is_a($arg, 'Superb')) {
               $su_children[] = $arg;
               
               /* now, since these Superb objects are now children
                  of this Superb object, we must remove them from top_level_su
                  as they are no longer 'top level' */
               if(($key = array_search($arg, $this->top_level_su)) !== false) {
                   unset($this->top_level_su[$key]);
               }
            } else if(is_callable($arg)) {
               /* given a function, so call it with a new Superb object as parameter */
               $sp = new Sp();
               call_user_func($arg, $sp);
               if($sp) {
                  /* add any markup created by the Superb object passed to the function */
                  $su_children = array_merge($su_children, $sp->get_top_su());
               }
            } else if(is_string($arg)) {
               /* treat as a Sp::raw tag */
               if($name == 'raw') $su->set('inner', $arg);
               else $su_children[] = new Superb('raw', $arg);
            } else if(is_array($arg)) {
               /* optional attributes */
               $su = self::parse_options($su, $options);
            }
         }
         
         $su->add($su_children);
      }

      if($save_su) {
         /* we record what markup has been generated by this particular Sp object */
         $this->top_level_su[] = $su;
      }
      
      return $su;
   }
   
   /* triggered when something like $sp->table() is called. */
   public function __call($name, $args) {
      return $this->parse_args($name, $args, true);
   }
   
   // triggered when something like Sp::table() is called
   public static function __callStatic($name, $args) {
      $sp = new Sp($name);
      return $sp->parse_args($name, $args);
   }
}
?>
